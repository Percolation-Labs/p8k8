# Things the agent should know

## User Profile & Personalization
- The agent knows the user profile exists and can load it via `get_user_profile`
- UserMetadata structure is understood: relations, interests, feeds, preferences, facts
- The agent knows that at any time it can update the user's profile via `update_user_metadata`, e.g. interests, even during casual conversation
- When the user reveals personal details (family, pets, location, hobbies, preferences), the agent proactively calls `update_user_metadata`
- The agent weaves known facts about the user naturally into conversation without being robotic about it
- Partial metadata updates are preferred — only send keys that changed

## REM Knowledge Base
- The agent understands REM (Resources, Entities, Moments)
  - There are different schemas which are well known or can be loaded for SQL-type queries
  - REM dialect modes SEARCH, LOOKUP, TRAVERSE, FUZZY can be used table-agnostic or targeted at specific tables:
    - `moments` — user memory (session chunks, dreams, uploads, reminders, web searches)
    - `resources` — user content (uploaded files, bookmarks, RSS articles, web search results)
    - `ontologies` — domain knowledge graph (concepts, documentation, system info)
  - SQL mode is available for date-range queries, aggregations, and complex filters
- The agent can recover long-term memories via semantic search or REM traversal of user moments
- The agent calls `search()` before answering factual questions rather than guessing
- LOOKUP is O(1) exact key lookup; SEARCH is semantic vector similarity; FUZZY is trigram text matching; TRAVERSE walks graph edges

## Memory & Moments
- The agent can query the user's memory timeline via `get_moments` with filters: moment_type, category, topic_tags, date ranges
- Known moment types: session_chunk, dream, web_search, reminder, content_upload, meeting, plot_collection
- Moments have topic_tags and emotion_tags for rich filtering
- Pagination is supported (limit/offset, has_more flag)
- The agent understands that dreams are cross-session syntheses generated by the dreaming agent in the background
- Session chunks are auto-generated summaries of past conversations

## Reminders & Scheduling
- The agent can create one-time reminders using ISO datetime strings (e.g. "2026-03-01T09:00:00")
- The agent can create recurring reminders using cron expressions (e.g. "0 9 * * 1" for every Monday at 9am)
- Default is ONE-TIME unless the user explicitly says "every", "daily", "weekly", "each", or similar recurring language
- Reminders trigger push notifications via pg_cron + pg_net
- Reminder names should be kebab-case (e.g. "take-vitamins", "weekly-standup")

## Web Search
- The agent can search the web via `web_search` using Tavily
- Search depth options: "basic" (faster) or "advanced" (deeper)
- Results are auto-saved as Resource entities for later REM recall (unless save=false)
- A Moment is auto-created to record each search event
- The agent respects daily quota limits on web searches

## Delegation & Multi-Agent
- The agent knows it can delegate to specialist agents via `ask_agent(agent_name, input_text)`
- Known specialist agents:
  - `researcher` — research topics, create Mermaid diagrams to visualize findings
  - `commerce-analyst` — inventory optimization, demand forecasting, anomaly detection, basket analysis, cashflow projection, staff scheduling (requires platoon)
  - `dreaming-agent` — background reflective synthesis (not user-invoked)
- The agent only delegates to `researcher` when the user explicitly asks to "research", "dig into", "investigate", etc. — not for simple questions
- The agent emits a `delegate` action event before delegating so the UI can track it
- Child agents stream tokens in real-time back through the parent in HTTP mode

## File & Data Analysis
- The agent can read uploaded files via `get_file(file_id)` — returns CSV rows or plain text
- Files are uploaded via the Percolate app, drive sync, or API
- The agent can discover uploaded files by searching moments for `content_upload` type or by searching resources
- For CSV files: columns, row_count, and rows (list of dicts) are returned
- The agent can pass file IDs directly to platoon tools (forecast, optimize, etc.) — they auto-resolve to local paths

## Visualization & Research
- The researcher agent creates Mermaid diagrams and saves them via `save_plot`
- Supported diagram types: graph (flowchart), sequenceDiagram, classDiagram, stateDiagram-v2, erDiagram, mindmap, timeline, pie, xychart-beta, quadrantChart, gantt, block-beta, sankey-beta, gitGraph
- Plot types: mermaid (default), chartjs, vega
- Plots are stored in session metadata and referenced via lightweight Moment pointers
- The agent returns diagram links as `[View diagram](moment://collection-key)` in responses

## Commerce & Inventory (Platoon tools)
- Demand forecasting: multiple methods (auto, moving_average, exponential_smoothing, croston, arima, ets, theta)
- Inventory optimization: EOQ, safety stock, reorder point, ABC classification, stockout risk
- Anomaly detection: spike/drop detection via zscore or IQR methods with configurable window and threshold
- Basket analysis: frequently-bought-together association rules with min_support and min_confidence thresholds
- Cashflow projection: daily revenue, COGS, and reorder cost projection over a configurable horizon
- Staff scheduling: assign staff to shifts based on demand signal and availability
- All platoon tools accept either local file paths or uploaded file UUIDs

## Conversational Awareness
- The agent classifies user intent: question, task, greeting, casual, follow-up, clarification
- The agent determines whether a search is needed before responding
- The agent picks appropriate search strategy (which REM mode, which table) based on the query
- The agent engages naturally in casual conversation — asks follow-ups, shows genuine interest
- The agent does not leak internal thinking/reasoning structure to the user
- The agent uses an active learning stance — treats every interaction as a chance to learn about the user

## Action Events & UI Integration
- The agent can emit `observation` events to record metadata (confidence, sources, reasoning)
- The agent can emit `elicit` events to request additional information from the user (triggers UI input)
- The agent can emit `delegate` events to signal delegation to another agent (for UI tracking)

## Agent Routing
- Lazy routing: the active agent persists across turns until completion or max_turns (default 20)
- No unnecessary reclassification on every turn — continuity is preferred
- Agents can opt into/out of routing and configure max_turns

## Encryption & Privacy
- Content fields in search results are auto-decrypted before being returned to the agent
- The agent never sees raw encrypted data — the platform handles decryption transparently
- PII redaction runs before embedding generation
