# ======================================================================
# AGENT RUN — Message spread from DB after persist_turn()
# ======================================================================
#
# Shows tool calls and responses as first-class message rows:
#   user → tool_call → tool_response → ... → assistant
#
# tool_call:     call metadata in tool_calls JSONB, content is NULL
# tool_response: tool result in content, correlation in tool_calls JSONB
#
# To regenerate: uv run python examples/capture_agent_run.py
# ======================================================================

description: 'Message spread from a single agent turn with tool calls and delegation.

  The agent called search (REM query), then delegated to the analyzer agent

  (structured output) via ask_agent.


  Sequence: user → tool_call → tool_response → tool_call → tool_response → assistant


  tool_call rows store call metadata (name, args, id) in tool_calls JSONB.

  tool_response rows store the tool result in content. For ask_agent, this

  captures the structured output artifact from the child agent.


  Generated by: uv run python examples/capture_agent_run.py'
session_id: b47feab5-cf20-44c2-9cc2-bb05432e23c0
agent: sample-agent
message_count: 6
messages:
- message_type: user
  content: Search for p8 architecture and ask the analyzer agent to summarize it
- message_type: tool_call
  tool_calls:
    id: call_search_001
    name: search
    arguments:
      query: SEARCH "p8 architecture" FROM resources LIMIT 3
  content: null
  agent_name: sample-agent
- message_type: tool_response
  tool_calls:
    id: call_search_001
    name: search
  content:
  - name: p8-architecture
    kind: resource
    summary: p8 is a minimal agentic framework where ontology is everything. Every entity — models, agents, evaluators, tools
      — is a row in the schemas table. Built on PostgreSQL 18, pgvector, pydantic-ai, FastAPI.
    topic_tags:
    - architecture
    - agents
    - postgresql
  - name: rem-query-system
    kind: resource
    summary: REM (Resource-Entity-Moment) query system supports LOOKUP, SEARCH, FUZZY, TRAVERSE, and SQL modes. All backed
      by pgvector embeddings and pg_trgm trigram indexes.
    topic_tags:
    - rem
    - search
    - embeddings
  agent_name: sample-agent
- message_type: tool_call
  tool_calls:
    id: call_ask_agent_001
    name: ask_agent
    arguments:
      agent_name: analyzer
      input_text: 'Analyze the p8 architecture: minimal agentic framework, PostgreSQL 18, pgvector, pydantic-ai, REM query
        system.'
  content: null
  agent_name: sample-agent
- message_type: tool_response
  tool_calls:
    id: call_ask_agent_001
    name: ask_agent
  content:
    status: success
    output:
      summary: p8 is a schema-driven agentic framework built on PostgreSQL where every entity is a database row. It combines
        pgvector embeddings with a multi-modal query system called REM.
      key_concepts:
      - schema-driven agents
      - ontology-as-database
      - pgvector embeddings
      - REM query system
      - pydantic-ai integration
      confidence: 0.92
    text_response: p8 is a schema-driven agentic framework...
    agent_schema: analyzer
    is_structured_output: true
  agent_name: sample-agent
- message_type: assistant
  content: Based on my search and the analyzer's assessment, p8 is a schema-driven agentic framework built on PostgreSQL 18.
    Its core idea is that ontology IS the database — every agent, model, and tool is a row in the schemas table. It uses pgvector
    for semantic search and a query system called REM that supports LOOKUP, SEARCH, FUZZY, and TRAVERSE modes. The analyzer
    identified 5 key concepts with 0.92 confidence.
  input_tokens: 1250
  output_tokens: 180
  latency_ms: 2340
  model: openai:gpt-4.1
  agent_name: sample-agent
